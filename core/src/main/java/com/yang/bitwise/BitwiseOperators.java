package com.yang.bitwise;

import org.junit.Test;

/**
 * 左移 右击 等运算符测试 代码一看就懂
 * 原码：将一个整数，转换成二进制，就是其原码。 如单字节的5的原码为：0000 0101；-5的原码为1000 0101。
 * 反码：正数的反码就是其原码；负数的反码是将原码中，除符号位以外，每一位取反。 如单字节的5的反码为：0000 0101；-5的反码为1111 1010。
 * 补码：正数的补码就是其原码；负数的反码+1就是补码(符号位除外)。 如单字节的5的补码为：0000 0101；-5的补码为1111 1011。
 * @author yangyang
 * @date 2019/8/5 17:39
 */
public class BitwiseOperators {
    /**
     * <<运算规则：末尾处补0
     */
    @Test
    public void leftShiftOperator() {
        // 正数 原补反 相等
        // 0000 0000 0000 0000 0000 0000 0000 0001
        int i = 1;
        // 负数
        // 原:1 000 0000 0000 0000 0000 0000 0000 0001
        // 反:1 111 1111 1111 1111 1111 1111 1111 1110 符号位除外其余取反
        // 补:1 111 1111 1111 1111 1111 1111 1111 1111 反码+1
        int j = -1;
        // 0 000 0000 0000 0000 0000 0000 0000 0001 --移动31位>1000 0000 0000 0000 0000 0000 0000 0000
        // 1000 0000 0000 0000 0000 0000 0000 0000--符号位为1（负数）--补码转源码(取反加一)>1111 1111 1111 1111 1111 1111 1111 1111+1-->1 1000 0000 0000 0000 0000 0000 0000 0000(-2147483648 溢出一位)
        System.out.println("i << 31:" + (i << 31));
        // 补:1111 1111 1111 1111 1111 1111 1111 1111--移动31位> 1000 0000 0000 0000 0000 0000 0000 0000(同上)
        System.out.println("j << 31:" + (j << 31));
    }

    /**
     * >> 右移 正数前面补0 负数前面补1 >>>正负数前面都补0 不存在<<<移动符号
     */
    @Test
    public void rightShiftOperator() {
        // 负数
        // 原:1000 0000 0000 0000 0000 0000 0000 0001
        // 反:1111 1111 1111 1111 1111 1111 1111 1110 符号位除外其余取反
        // 补:1111 1111 1111 1111 1111 1111 1111 1111 反码+1
        int j = -1;
        // 正数 原补反 相等--> 0111 1111 1111 1111 1111 1111 1111 1111
        int k = 2147483647;
        // 源:1111 1111 1111 1111 1111 1111 1111 1111
        // 反:1000 0000 0000 0000 0000 0000 0000 0000
        // 补:1000 0000 0000 0000 0000 0000 0000 0001
        int l = -2147483647;
        // 源:1 1000 0000 0000 0000 0000 0000 0000 0000
        // 反:1 0111 1111 1111 1111 1111 1111 1111 1111
        // 补:1 1000 0000 0000 0000 0000 0000 0000 0000(因为只有32位 所以前面的符号位是不存在的)
        int m = -2147483648;
        System.out.println("k>>31:" + (k >> 31));
        // 补:1000 0000 0000 0000 0000 0000 0000 0001-->1111 1111 1111 1111 1111 1111 1111 1111--补码转源码(取反加一)>1000 0000 0000 0000 0000 0000 0000 0001
        System.out.println("l>>31:" + (l >> 31));
        // 补:1 1000 0000 0000 0000 0000 0000 0000 0000-->1111 1111 1111 1111 1111 1111 1111 1111--补码转源码(取反加一)>1000 0000 0000 0000 0000 0000 0000 0001
        System.out.println("m>>31:" + (m >> 31));
        // 补:1111 1111 1111 1111 1111 1111 1111 1111 右移多少位都是-1
        System.out.println("j >> 31:" + (j >> 31));

        // 补:1111 1111 1111 1111 1111 1111 1111 1111-->0111 1111 1111 1111 1111 1111 1111 1111
        System.out.println("j >>> 1:" + (j >>> 1));
        // 补:1 1000 0000 0000 0000 0000 0000 0000 0000-->0100 0000 0000 0000 0000 0000 0000 0000
        System.out.println("m >>> 1:" + (m >>> 1));
    }

    /**
     * & 运算规则：0 & 0 = 0;0 & 1 = 0;1 & 0 = 0;1 & 1 = 1
     */
    @Test
    public void andOperation() {
        int i = 1;
        int l = -2147483647;
        // i:0000 0000 0000 0000 0000 0000 0000 0001
        // l:1000 0000 0000 0000 0000 0000 0000 0001
        // &:0000 0000 0000 0000 0000 0000 0000 0001
        System.out.println(i & l);
    }

    /**
     * |运算规则： 0 | 0 = 0;0 | 1 = 1;1 | 0 = 1;1 | 1 = 1;
     */
    @Test
    public void orOperation() {
        int i = 1;
        int l = -2147483647;
        // i:0000 0000 0000 0000 0000 0000 0000 0001
        // l:1000 0000 0000 0000 0000 0000 0000 0001
        // |:1000 0000 0000 0000 0000 0000 0000 0001
        System.out.println(i | l);
    }

    /**
     * ^运算规则： 0 ^ 0 = 0;0 ^ 1 = 1;1 ^ 0 = 1;1 ^ 1 = 0;
     */
    @Test
    public void heteroOperator() {
        int i = 1;
        int l = -2147483647;
        // i:0000 0000 0000 0000 0000 0000 0000 0001
        // l:1000 0000 0000 0000 0000 0000 0000 0001
        // ^:1000 0000 0000 0000 0000 0000 0000 0000
        System.out.println(i ^ l);
    }

    /**
     * ~运算规则： ~1 = 0; ~0 = 1;
     */
    @Test
    public void antiOperator() {
        int i = 1;
        // i:0000 0000 0000 0000 0000 0000 0000 0001
        // ~:1111 1111 1111 1111 1111 1111 1111 1110 --> 1000 0000 0000 0000 0000 0000 0000 0001+1 --> -2
        System.out.println(~i);
    }

    /**
     * 不使用第三个变量交换两个变量的值
     */
    @Test
    public void swap1() {
        int a = 5;
        int b = 7;
        System.out.println("befor,a:" + a + ",b:" + b);
        a = a ^ b;
        b = b ^ a;
        a = a ^ b;
        System.out.println("after,a:" + a + ",b:" + b);
    }

    /**
     * 不使用第三个变量交换两个变量的值
     */
    @Test
    public void swap2() {
        int a = 5;
        int b = 7;
        System.out.println("befor,a:" + a + ",b:" + b);
        a = b - a;
        b = b - a;
        a = b + a;
        System.out.println("after,a:" + a + ",b:" + b);
    }

    /**
     * 不使用第三个变量交换两个变量的值
     */
    @Test
    public void swap3() {
        int a = 5;
        int b = 7;
        System.out.println("befor,a:" + a + ",b:" + b);
        if (a < b) {
            a = (int) (b - a);
            b = (int) (b - (a & 0x0000ffff));
            a = (int) (b + (a & 0x0000ffff));
        } else {
            b = (int) (a - b);
            a = (int) (a - (b & 0x0000ffff));
            b = (int) (a + (b & 0x0000ffff));
        }
        System.out.println("after,a:" + a + ",b:" + b);
    }

}
